<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.53" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Java集合 | Alex的博客</title>
    <meta property="og:title" content="Java集合 - Alex的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-05-25T23:02:48&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-05-25T23:02:48&#43;08:00">
        
    <meta name="Keywords" content="Java,设计模式">
    <meta name="description" content="Java集合">
        <meta name="author" content="Alex">
        
    <meta property="og:url" content="https://wangjc95.com/post/1-java%E9%9B%86%E5%90%88/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://wangjc95.com">
                        Alex的博客
                    </a>
                
                <p class="description">Java程序猿</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://wangjc95.com">首页</a>
                    
                    <a  href="https://wangjc95.com/archives/" title="归档">归档</a>
                    
                    <a  href="https://wangjc95.com/about/" title="About">About</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">Java集合</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年5月25日
                        </date>
                        
                        <div class="post-meta">
                            <span>|</span>
                            
                                <span class="meta-category"><a href="https://wangjc95.com/categories/javase">javaSE</a></span>
                            
                        </div>
                        
                        
                        <div class="post-meta">
                            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span> 阅读</span></span>
                        </div>
                        
                        
                        <div class="post-content">
                            

<p>[TOC]</p>

<h1 id="1-collection-和-iterator-接口">1.<code>Collection</code>和<code>Iterator</code>接口</h1>

<h2 id="1-1-iterator">1.1<code>Iterator</code></h2>

<p><code>Iterator</code>接口也是<code>Java</code>集合框架的成员,但它与<code>Collection</code>系列,<code>Map</code>系列的集合不一样:<code>Collection</code>系列集合,<code>Map</code>系列集合主要用于装其他对象,而<code>Iterator</code>则主要用于遍历(即迭代访问)<code>Collection</code>集合中的元素,<code>Iterator</code>对象也被称为迭代器.</p>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    @Test
    public void test5() {
        List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;Java&quot;, &quot;Python&quot;, &quot;Go&quot;, &quot;Swift&quot;, &quot;JavaScript&quot;));
        System.out.println(&quot;list未迭代之前-&gt;&quot; + list);
        //第一次迭代
        Iterator&lt;String&gt; iterator = list.iterator();
        while (iterator.hasNext()) {
            String next = iterator.next();
            //修改next值,不会影响集合元素本身
            next = &quot;Test&quot;;
        }
        System.out.println(&quot;第一次迭代-&gt;&quot; + list);

        //第二次迭代
        //迭代器已进行过一次遍历,需要对迭代器重新赋值
        iterator = list.iterator();
        while (iterator.hasNext()) {
            String next = iterator.next();
            //通过iterator删除集合中的Java元素
            if (next.equals(&quot;Java&quot;)) {
                iterator.remove();
            }
        }
        System.out.println(&quot;第二次迭代-&gt;&quot; + list);

        //第三次迭代
        //迭代器已进行过一次遍历,需要对迭代器重新赋值
        iterator = list.iterator();
        while (iterator.hasNext()) {
            String next = iterator.next();
            //在迭代过程中,对集合本身进行修改,会导致ConcurrentModificationException异常
            if (next.equals(&quot;Python&quot;)) {
                list.remove(next);
            }
        }
        System.out.println(&quot;第三次迭代-&gt;&quot; + list);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>list未迭代之前-&gt;[Java, Python, Go, Swift, JavaScript]
第一次迭代-&gt;[Java, Python, Go, Swift, JavaScript]
第二次迭代-&gt;[Python, Go, Swift, JavaScript]

java.util.ConcurrentModificationException
</code></pre>

<p>在第一次迭代中,对迭代变量<code>next</code>赋值,但当再次输出<code>list</code>集合时,回发现集合里的元素没有任何改变.这就可以得出一个结论:当使用<code>Iterator</code>对集合元素进行迭代时,<code>Iterator</code>并不是把集合元素本身传给了迭代变量,而是把集合元素的值传给了迭代变量,所以修改迭代变量的值对集合元素本身没有任何影响.</p>

<p>在第二次和第三次迭代中说明了在使用<code>Iterator</code>迭代器访问<code>Collection</code>集合元素时,<code>Collection</code>集合里的元素不能被改变,只有通过<code>Iterator</code>的<code>remove()</code>方法删除上一次<code>next()</code>方法返回的集合元素才可以:否则将会引发<code>java.util.ConcurrentModificationExcepiton</code>异常.</p>

<p>同样,当使用<code>foreach</code>循环迭代访问集合元素时,该集合也不能被改变.</p>

<h2 id="1-2-predicate">1.2<code>Predicate</code></h2>

<p>使用<code>Java</code>8新增的<code>Predicate</code>关键字来操作集合.(也可直接通过<code>Stream</code>来完成其操作)</p>

<pre><code class="language-java">    @Test
    public void test7() {
        List&lt;String&gt; books = new ArrayList&lt;&gt;(Arrays.asList(&quot;Java编程思想&quot;, &quot;并发编程&quot;, &quot;深入理解Java虚拟机&quot;, &quot;Head First Java设计模式&quot;, &quot;Spring实战&quot;, &quot;图解HTTP&quot;));
        //获取books集合中包含Java字符串的元素个数
        System.out.println(calTotal(books, str -&gt; ((String) str).contains(&quot;Java&quot;)));
        //获取books集合中元素长度大于8的元素个数
        System.out.println(calTotal(books, str -&gt; ((String) str).length() &gt; 8));

        System.out.println(&quot;原List-&gt;&quot; + books);
        //删除大于8的元素
        books.removeIf(str -&gt; str.length() &gt; 8);
        System.out.println(&quot;操作过后List-&gt;&quot; + books);
    }

    private int calTotal(Collection list, java.util.function.Predicate predicate) {
        int total = 0;
        for (Object object : list) {
            if (predicate.test(object)) {
                total++;
            }
        }
        return total;
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>3
原List-&gt;[Java编程思想, 并发编程, 深入理解Java虚拟机, Head First Java设计模式, Spring实战, 图解HTTP]
操作过后List-&gt;[Java编程思想, 并发编程, Spring实战, 图解HTTP]
</code></pre>

<h1 id="2-set-集合">2.<code>Set</code>集合</h1>

<p><code>Set</code>集合无序不可重复.</p>

<h2 id="2-1-hashset">2.1<code>HashSet</code></h2>

<p><code>HashSet</code>是Set接口的典型实现,大多数使用<code>Set</code>集合时就是使用这个实现类.<code>HashSet</code>按<code>Hash</code>算法来存储集合中的元素,因此具有很好的存取和查找性能.</p>

<p><code>HashSet</code>具有以下特点:</p>

<ul>
<li>不能保证元素的排列顺序,顺序可能与添加顺序不同;</li>
<li><code>HashSet</code>不是线程安全的;</li>
<li>集合元素值可以是<code>null</code>;</li>
</ul>

<p><strong><code>hashCode()</code>与<code>HashSet</code>之间的关系</strong></p>

<p><code>hash</code>(也被翻译为哈希,散列)算法的功能是,它能保证快速查找被检索的对象,<code>hash</code>算法的价值在于速度.当需要查询集合中某个元素时,<code>hash</code>算法可以直接根据该元素的<code>hashCode</code>值计算出该元素的存储位置,从而快速定位该元素.</p>

<p><strong><code>HashSet</code>集合判断两个元素相等的标准是两个对象通过<code>equal()</code>方法比较是否相等,并且两个对象的<code>hashCode()</code>方法返回值也相等.</strong></p>

<p>如果两个对象通过<code>equals()</code>方法比较返回<code>true</code>,但这两个对象的<code>hashCode()</code>方法返回不同的<code>hashCode</code>值时,这将导致<code>HashSet</code>会把这两个对象保存在<code>Hash</code>表的不同位置,从而使两个对象都可以添加成功,这就与<code>Set</code>集合的规则冲突了.</p>

<p><code>HashSet</code>中每个能存储元素的&rdquo;槽位&rdquo;(<code>slot</code>)通常称为&rdquo;桶&rdquo;(<code>bucket</code>),如果有多个元素的<code>hashCode</code>值相同,但它们通过<code>equals()</code>方法比较返回<code>false</code>,就需要在一个&rdquo;桶&rdquo;里放多个元素,这样会导致性能下降.</p>

<p><strong>测试代码:</strong></p>

<pre><code class="language-java">    class A {
        @Override
        public int hashCode() {
            return 1;
        }
    }

    class B {
        @Override
        public boolean equals(Object obj) {
            return true;
        }
    }

    class C {
        @Override
        public int hashCode() {
            return 10;
        }

        @Override
        public boolean equals(Object obj) {
            return true;
        }
    }


    @Test
    public void test38() {
        Set set = new HashSet();
        set.add(new A());
        set.add(new A());
        set.add(new B());
        set.add(new B());
        set.add(new C());
        set.add(new C());
        System.out.println(set);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>[PersonalTest$A@1, PersonalTest$A@1, PersonalTest$B@5e8c92f4, PersonalTest$C@a, PersonalTest$B@61e4705b]
</code></pre>

<p><code>Set</code>集合中只有<code>C</code>对象是唯一的,因为它的<code>hashCode()</code>和<code>equals(Object obj)</code>返回均相同.</p>

<p><strong>当向<code>HashSet</code>中添加可变对象时,必须十分小心.如果修改<code>HashSet</code>集合中的对象,有可能导致该对象与集合中的其他对象相等,从而导致<code>HashSet</code>无法准确访问该对象.</strong></p>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    class R {
        private int count;

        public void setCount(int count) {
            this.count = count;
        }

        public R(int count) {
            this.count = count;
        }

        @Override
        public boolean equals(Object object) {
            if (this == object) return true;
            if (object == null || getClass() != object.getClass()) return false;

            R r = (R) object;

            return count == r.count;
        }

        @Override
        public int hashCode() {
            return count;
        }

        @Override
        public String toString() {
            return &quot;R{&quot; +
                    &quot;count=&quot; + count +
                    '}';
        }
    }

    @Test
    public void test8() {
        Set&lt;R&gt; set = new HashSet&lt;&gt;();
        set.add(new R(1));
        set.add(new R(2));
        set.add(new R(3));
        set.add(new R(4));
        System.out.println(set);

        //更改其中一个元素为R(2),此处中改变的是R(1)
        Iterator&lt;R&gt; iterator = set.iterator();
        R r1 = iterator.next();
        r1.setCount(2);

        //此时set拥有了重复的元素
        System.out.println(set);

        //删除R(2),根据R(2)的hashCode值,删除R(2),而不是替换R(1)的R(2)
        set.remove(new R(2));

        //此时剩下的是 替换R(1)的R(2),R(3),R(4)
        System.out.println(set);

        //根据R(1)的hashCode值,找到当前set中的R(2),但由于equals()返回false(count值不同),所以输出false
        System.out.println(set.contains(new R(1)));
        //R(2)的hashCode值在之前的remove(new R(2))中已经被移除,所以输出false
        System.out.println(set.contains(new R(2)));
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>[R{count=1}, R{count=2}, R{count=3}, R{count=4}]
[R{count=2}, R{count=2}, R{count=3}, R{count=4}]
[R{count=2}, R{count=3}, R{count=4}]
false
false
</code></pre>

<h2 id="2-2-linkedhashset">2.2<code>LinkedHashSet</code></h2>

<p><code>LinkedHashSet</code>也是根据元素的<code>hashCode</code>值来决定元素的存储位置,但它同时使用链表维护元素的次序.因此它是有序,不可重复的.但是性能略低于<code>HashSet</code>.但是它在迭代访问<code>Set</code>里的全部元素时将有很好的性能,因为它以链表来维护内部顺序.
<strong>示例代码:</strong></p>

<pre><code class="language-java">    @Test
    public void test39() {
        LinkedHashSet&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();
        linkedHashSet.add(&quot;Java&quot;);
        linkedHashSet.add(&quot;Python&quot;);
        linkedHashSet.add(&quot;Go&quot;);
        linkedHashSet.add(&quot;Swift&quot;);
        System.out.println(linkedHashSet);
        linkedHashSet.remove(&quot;Java&quot;);
        linkedHashSet.add(&quot;Java&quot;);
        //可以看出Java 字符串 从首跑到了尾
        System.out.println(linkedHashSet);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>[Java, Python, Go, Swift]
[Python, Go, Swift, Java]
</code></pre>

<h2 id="2-3-treeset">2.3<code>TreeSet</code></h2>

<p><code>TreeSet</code>有序,不可重复.<code>TreeSet</code>并不是根据元素的插入顺序进行排序的,而是根据元素实际值的大小来进行排序的.<code>TreeSet</code>采用红黑树的数据结构来存储集合元素.</p>

<h3 id="2-3-1自然排序">2.3.1自然排序</h3>

<p>自然排序需要确保<code>TreeSet</code>中的对象实现了<code>Comparable</code>接口.</p>

<p>当两个对象通过<code>compare(Object obj)</code>方法返回0时,这两对象的<code>equals()</code>方法返回<code>true</code>.此时<code>TreeSet</code>不会把第二个元素添加到集合中.</p>

<pre><code class="language-java">    @Test
    public void test40() {
        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();
        treeSet.add(5);
        treeSet.add(-3);
        treeSet.add(7);
        treeSet.add(-2);
        System.out.println(treeSet);
        //输出集合中的第一个元素
        System.out.println(treeSet.first());
        //输出集合中的最后一个元素
        System.out.println(treeSet.last());
        //返回小于-2的子集,不包含-2
        System.out.println(treeSet.headSet(-2));
        //返回大于等于5的子集,包含5
        System.out.println(treeSet.tailSet(5));
        //返回大于等于-2,小于5的子集
        System.out.println(treeSet.subSet(-2, 5));
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>[-3, -2, 5, 7]
-3
7
[-3]
[5, 7]
[-2]
</code></pre>

<h3 id="2-3-2定制排序">2.3.2定制排序</h3>

<p>定制排序时不再要求<code>Set</code>元素实现<code>Comparable</code>接口.</p>

<pre><code class="language-java">    class T {
        private int count;

        public T(int count) {
            this.count = count;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            T t = (T) o;
            return count == t.count;
        }

        @Override
        public int hashCode() {
            return Objects.hash(count);
        }

        public int getCount() {
            return count;
        }

        @Override
        public String toString() {
            return &quot;T{&quot; +
                    &quot;count=&quot; + count +
                    '}';
        }
    }

    @Test
    public void test48() {
        //使TreeSet按照从大到小的顺序排列.
        TreeSet&lt;T&gt; treeSet = new TreeSet&lt;T&gt;((o1, o2) -&gt; {
            return Integer.compare(o2.getCount(), o1.getCount());
        });
        treeSet.add(new T(3));
        treeSet.add(new T(-1));
        treeSet.add(new T(2));
        treeSet.add(new T(6));
        System.out.println(treeSet);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>[T{count=6}, T{count=3}, T{count=2}, T{count=-1}]
</code></pre>

<h2 id="2-4-enumset">2.4<code>EnumSet</code></h2>

<p><code>EnumSet</code>是一个专为枚举类设计的集合类,<code>EnumSet</code>中的所有元素都必须是指定枚举类型的枚举值.<code>EnumSet</code>的集合元素也是有序的,它以枚举值在<code>Enum</code>类内的定义顺序来决定集合元素的顺序.</p>

<p><code>EnumSet</code>在内部以位向量的形式存储,这种存储非常紧凑,高效.因此<code>EnumSet</code>对象占用内存很小,而且运行效率很好.<code>EnumSet</code>集合不允许加入<code>null</code>元素,否则将会抛出<code>NullPointerException</code>异常.</p>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    enum Season {
        SPRING, SUMMER, FALL, WINTER
    }

    @Test
    public void test42() {
        //创建一个EnumSet枚举类,集合元素时Season的全部枚举值
        EnumSet&lt;Season&gt; es1 = EnumSet.allOf(Season.class);
        System.out.println(es1);
        for (Season season : es1) {
            System.out.println(season.ordinal());
        }

        //创建一个空的EnumSet,指定其集合元素是Season类的枚举值
        EnumSet&lt;Season&gt; es2 = EnumSet.noneOf(Season.class);
        es2.add(Season.SUMMER);
        es2.add(Season.WINTER);
        System.out.println(es2);

        //以指定枚举值创建EnumSet集合
        EnumSet&lt;Season&gt; es3 = EnumSet.of(Season.SPRING, Season.FALL);
        System.out.println(es3);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>[SPRING, SUMMER, FALL, WINTER]
0
1
2
3
[SUMMER, WINTER]
[SPRING, FALL]
</code></pre>

<h2 id="2-5各-set-实现类的性能分析">2.5各<code>Set</code>实现类的性能分析</h2>

<p><code>HashSet</code>和<code>TreeSet</code>是<code>Set</code>的典型实现.<code>HashSet</code>的性能比<code>TreeSet</code>要好,因为<code>TreeSet</code>需要额外的红黑树算法来维护集合的次序.所以如果需要<code>Set</code>有序时,使用<code>TreeSet</code>,否则使用<code>HashSet</code>.</p>

<p><code>HashSet</code>还有一个子类<code>LinkedHashSet</code>,对于普通的插入,删除操作,<code>LinkedHashSet</code>比<code>HashSet</code>要略微慢一点,这是由于维护链表所带来的额外开销造成的,但由于有了链表,遍历<code>LinkedHashSet</code>会更快.</p>

<p><code>EnumSet</code>是所有<code>Set</code>实现类中性能最好的,但它只能保存同一个枚举类的枚举值作为集合元素.</p>

<p><code>HashSet</code>,<code>LinkedHashSet</code>,<code>TreeSet</code>和<code>EnumSet</code>都是线程不安全的,通常可以通过<code>Collections</code>工具类的<code>synchronizedSortedSet</code>方法来包装<code>Set</code>集合.</p>

<h1 id="3-list-集合">3.<code>List</code>集合</h1>

<p><code>List</code>集合代表一个元素有序,可重复的集合.<code>List</code>集合允许使用重复元素,默认按照元素的添加顺序设置元素的索引,可以通过索引来访问指定位置的集合元素.</p>

<h2 id="3-1-list-根据-equals-判断元素是否存在">3.1<code>List</code>根据<code>equals</code>判断元素是否存在</h2>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    class L {
        public L() {
        }

        @Override
        public boolean equals(Object obj) {
            return true;
        }
    }

    @Test
    public void test43() {
        List list = new ArrayList();
        list.add(&quot;AA&quot;);
        list.add(&quot;BB&quot;);
        list.add(&quot;CC&quot;);
        System.out.println(list);
        //因为L对象equals一直返回true,所以删除此时处于第一个对象的&quot;AA&quot;
        list.remove(new L());
        System.out.println(list);
        //删除此时处于第一个对象的&quot;BB&quot;
        list.remove(new L());
        System.out.println(list);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>[AA, BB, CC]
[BB, CC]
[CC]
</code></pre>

<h2 id="3-2-sort-和-replaceall-方法">3.2<code>sort</code>和<code>replaceAll</code>方法</h2>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    @Test
    public void test44() {
        List&lt;String&gt; books = new ArrayList&lt;&gt;(Arrays.asList(&quot;AA&quot;, &quot;BBBBBBB&quot;, &quot;C&quot;, &quot;DDDD&quot;, &quot;EEE&quot;, &quot;FFFFF&quot;));
        System.out.println(books);
        books.sort((o1, o2) -&gt; o1.length() - o2.length());
        System.out.println(&quot;after sorted-&gt;&quot; + books);
        books.replaceAll(ele -&gt; String.valueOf(ele.length()));
        System.out.println(&quot;after replaced-&gt;&quot; + books);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>[AA, BBBBBBB, C, DDDD, EEE, FFFFF]
after sorted-&gt;[C, AA, EEE, DDDD, FFFFF, BBBBBBB]
after replaced-&gt;[1, 2, 3, 4, 5, 7]
</code></pre>

<h2 id="3-3-arraylist-和-vector-实现类">3.3<code>ArrayList</code>和<code>Vector</code>实现类</h2>

<p><code>ArrayList</code>和<code>Vector</code>作为<code>List</code>类的两个典型实现，完全支持前面介绍的<code>List</code>接口的全部功能。</p>

<p><code>ArrayList</code>和<code>Vector</code>类都是基于数组实现的<code>List</code>类，所以<code>ArrayList</code>和<code>Vector</code>类封装了一个动态的、允许再分配<code>Object[]</code>数组。<code>ArrayList</code>或<code>Vector</code>对象使用<code>initialCapacity</code>参数来设置该数组的长度，当向<code>ArrayList</code>或<code>Vector</code>中添加元素超出该数组的长度时，它们的<code>initialCapacity</code>会自动增加。
对于通常的编程场景，程序员无需关心<code>ArrayList</code>或<code>Vector</code>的<code>initialCapacity</code>。但如果向<code>ArrayList</code>或<code>Vector</code>集合中添加大量元素时，可使用<code>ensureCapacity（int minCapacity）</code>方法一次性地增加<code>initialCapacity</code>。这可以减少重分配的次数，从而提高性能。
如果开始就知道<code>ArrayList</code>或<code>Vector</code>集合需要保存多少个元素，则可以在创建它们时就指定<code>initialCapacity</code>大小。如果创建空的<code>ArrayList</code>或<code>Vector</code>集合时不指定<code>initialCapacity</code>参数，则<code>Object[]</code>数组的长度默认为10。除此之外，<code>ArrayList</code>和<code>Vector</code>还提供了如下两个方法来重新分配Object[]数组。</p>

<ul>
<li><code>void ensureCapacity(int minCapacity)</code>：将<code>ArrayList</code>或<code>Vector</code>集合的<code>Object[]</code>数组长度增加<code>minCapacity</code>。</li>
<li><code>void trimToSize()</code>：调整<code>ArrayList</code>或<code>Vector</code>集合的<code>Object[]</code>数组长度为当前元素的个数。程序可调用该方法来减少<code>ArrayList</code>或<code>Vector</code>集合对象占用的存储空间。</li>
</ul>

<p><code>ArrayList</code>和<code>Vector</code>在用法上几乎完全相同，但由于<code>Vector</code>是一个古老的集合，实际上<code>Vector</code>具有很多缺点，通常尽量少用<code>Vector</code>实现类。
除此之外，<code>ArrayList</code>和<code>Vector</code>的显著区别是：<code>ArrayList</code>是线程不安全的，当多个线程访问同一个<code>ArrayList</code>集合时，如果有超过一个线程修改了<code>ArrayList</code>集合，则程序必须手动保证该集合的同步性；但<code>Vector</code>集合则是线程安全的，无需程序保证该集合的同步性,所以<code>Vector</code>的性能比<code>ArrayList</code>的性能要低。实际上，即使需要保证<code>List</code>集合线程安全，也同样不推荐使用<code>Vector</code>实现类。后面会介绍一个<code>Collections</code>工具类，它可以将一个<code>ArrayList</code>变成线程安全的。
<code>Vector</code>还提供了一个<code>Stack</code>子类，它用于模拟“栈”这种数据结构，“栈”通常是指“后进先出”（<code>LIFO</code>）的容器。最后“<code>push</code>”进栈的元素，将最先被“<code>pop</code>”出栈。与<code>Java</code>中的其他集合一样，进栈出栈的都是<code>Object</code>，因此从栈中取出元素后必须进行类型转换，除非你只是使用<code>Object</code>具有的操作。所以<code>Stack</code>类里提供了如下几个方法。</p>

<ul>
<li><code>Object peek()</code>：返回“栈”的第一个元素，但并不将该元素“<code>pop</code>”出栈。</li>
<li><code>Object pop()</code>：返回“栈”的第一个元素，并将该元素“<code>pop</code>”出栈。</li>
<li><code>void push(Object item)</code>：将一个元素“<code>push</code>”进栈，最后一个进“栈”的元素总是位于“栈”顶。</li>
</ul>

<p>需要指出的是,由于<code>Stack</code>继承了<code>Vector</code>,因此它也是一个非常古老的<code>Java</code>集合类,它同样是线程安全,性能较差的.因此应该尽量少用<code>Stack</code>类.如果程序需要使用<strong>栈</strong>这种数据结构,则可以考虑使用后面将要介绍的<code>ArrayDeque</code></p>

<h2 id="3-4固定长度的-list">3.4固定长度的<code>List</code></h2>

<p><code>Arrays.asList</code>是一个固定长度的<code>List</code>集合,程序只能遍历访问该集合里的元素,不可增加,删除该集合里的元素.</p>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    @Test
    public void test46() {
        //固定长度的List,对于该List的任何操作都会触发UnsupportedOperationException异常
        List&lt;String&gt; list1 = Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;);
        //比如添加就会触发异常
        //list1.add(&quot;AA&quot;);

        //将list1放入ArrayList()中,既初始化了集合,也使集合变得可变
        List&lt;String&gt; list2 = new ArrayList&lt;&gt;(list1);
        list2.add(&quot;G&quot;);
        System.out.println(list2);
    }
</code></pre>

<h1 id="4-queue-集合">4.<code>Queue</code>集合</h1>

<p><code>Queue</code>用于模拟队列这种数据结构,队列通常是指<strong>先进先出</strong>(<code>FIFO</code>)的容器.队列的头部保存队列中存放最久的元素,队列的尾部保存在队列中存放时间最短的元素.新元素插入到队列的尾部,访问元素会返回队列头部的元素.</p>

<p><code>Queue</code>接口有一个<code>PriorityQueue</code>实现类.除此之外,<code>Queue</code>还有一个<code>Deque</code>接口,<code>Deque</code>代表一个<strong>双端队列</strong>,双端队列可以同时从两端来添加,删除元素,因此<code>Deque</code>的实现类既可当成队列使用,也可以当成栈使用.<code>Java</code>为<code>Deque</code>提供了<code>ArrayDeque</code>和<code>LinkedList</code>两个实现类.</p>

<h2 id="4-1-priorityqueue-实现类">4.1<code>PriorityQueue</code>实现类</h2>

<p><code>PriorityQueue</code>保存队列元素的顺序不是按照加入队列的顺序,而是按队列元素的大小进行重新排序.因此当调用<code>peek</code>方法或<code>poll</code>方法去除队列中的元素时,并不是取出最先进入队列的元素,而是取出最小的元素.</p>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    @Test
    public void test47() {
        PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;();
        priorityQueue.add(3);
        priorityQueue.add(-4);
        priorityQueue.add(10);
        priorityQueue.add(-10);
        //直接输出priorityQueue集合时,可能看到该队列没有完全按照从小到大的顺序输出,这是受到PriorityQueue的toString方法的影响
        System.out.println(priorityQueue);
        //正确的输出priorityQueue对象的方法
        int size = priorityQueue.size();
        for (int i = 0; i &lt; size; i++) {
            System.out.println(priorityQueue.poll());
        }
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>[-10, -4, 10, 3]
-10
-4
3
10
</code></pre>

<p><code>PriorityQueue</code>不允许插入<code>null</code>元素.<code>PriorityQueue</code>的元素有两种排序:自然排序和定制排序,参照2.3节的<code>TreeSet</code>.</p>

<h2 id="4-2-deque-接口与-arraydeque-实现类">4.2<code>Deque</code>接口与<code>ArrayDeque</code>实现类</h2>

<p><code>Deque</code>接口是<code>Queue</code>接口的子接口,它代表一个双端队列.<code>Deque</code>接口提供了一个典型的实现类<code>ArrayDeque</code>,从该名称可以看出,它是一个基于数组实现的双端队列,创建<code>Deque</code>时同样可指定一个<code>numElements</code>参数,该参数用于指定<code>Object[]</code>数组的长度:如果不指定<code>numElements</code>参数,<code>Deque</code>底层数组的长度为16.它与<code>ArrayList</code>的实现机制基本相似.</p>

<p><strong>将<code>ArrayDeque</code>当成栈来使用</strong></p>

<pre><code class="language-java">    @Test
    public void test49() {
        ArrayDeque stack = new ArrayDeque();
        //将一个元素push进该双端队列的栈顶
        stack.push(&quot;Java&quot;);
        stack.push(&quot;Ios&quot;);
        stack.push(&quot;Python&quot;);
        //输出stack
        System.out.println(stack);
        //获取栈顶元素但不删除
        System.out.println(stack.peek());
        System.out.println(stack);
        //获取并删除栈顶元素
        System.out.println(stack.poll());
        System.out.println(stack);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>[Python, Ios, Java]
Python
[Python, Ios, Java]
Python
[Ios, Java]
</code></pre>

<p><strong>将<code>ArrayDeque</code>当做队列使用</strong></p>

<pre><code class="language-java">    @Test
    public void test50() {
        ArrayDeque queue = new ArrayDeque();
        //将元素放入deque的尾部
        queue.offer(&quot;Java&quot;);
        queue.offer(&quot;Ios&quot;);
        queue.offer(&quot;Python&quot;);
        System.out.println(queue);
        System.out.println(queue.peek());
        System.out.println(queue);
        System.out.println(queue.poll());
        System.out.println(queue);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>[Java, Ios, Python]
Java
[Java, Ios, Python]
Java
[Ios, Python]
</code></pre>

<h2 id="4-3-linkedlist-实现类">4.3<code>LinkedList</code>实现类</h2>

<p><code>LinkedList</code>类是<code>List</code>接口的实现类,这意味着它是一个<code>List</code>集合,可以根据索引来随即访问集合中的元素.除此之外,<code>LinkedList</code>还实现了<code>Deque</code>接口,可以被当成双端队列来使用,因此既可以被当成<strong>栈</strong>来使用,也可以当成<strong>队列</strong>使用.</p>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    @Test
    public void test51() {
        LinkedList books = new LinkedList();
        //放到队列的尾部
        books.offer(&quot;Java&quot;);
        //放到栈的顶部
        books.push(&quot;Ios&quot;);
        //放到队列的头部,相当于栈的顶部
        books.offerFirst(&quot;Python&quot;);
        //作为集合的用法,
        for (int i = 0; i &lt; books.size(); i++) {
            System.out.println(books.get(i));
        }
        System.out.println(&quot;================&quot;);
        System.out.println(books);
        //访问并不删除栈顶的元素   Python
        System.out.println(books.peekFirst());
        System.out.println(books);
        //访问并不删除队列最后的一个元素   Java
        System.out.println(books.peekLast());
        System.out.println(books);
        //弹出栈顶的元素   Python
        System.out.println(books.pop());
        System.out.println(books);
        //弹出队列尾部的元素 Java
        System.out.println(books.pollLast());
        System.out.println(books);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>Python
Ios
Java
================
[Python, Ios, Java]
Python
[Python, Ios, Java]
Java
[Python, Ios, Java]
Python
[Ios, Java]
Java
[Ios]
</code></pre>

<p><code>LinkedList</code>与<code>ArrayList</code>,<code>ArrayDeque</code>的实现机制完全不同,<code>ArrayList</code>,<code>ArrayDeque</code>内部以数组的形式来保存集合中的元素,因此随机访问集合元素时有较好的性能:而<code>LinkedList</code>内部以链表的形式来保存集合中的元素,因此随即访问集合元素时性能较差,但在插入,删除元素时性能比较出色.</p>

<h2 id="4-4总结">4.4总结</h2>

<ul>
<li>如果需要遍历<code>List</code>集合元素,对于<code>ArrayList</code>,<code>Vector</code>集合,应该使用随机访问方法(<code>get</code>)来遍历集合元素,这样性能更好.对于<code>LinkedList</code>集合,则应该采用迭代器<code>Iterator</code>来遍历集合元素.</li>
<li>如果需要经常执行插入,删除操作来改变包含大量数据的<code>List</code>集合的大小,可考虑使用<code>LinkedList</code>集合.使用<code>ArrayList</code>,<code>Vector</code>集合可能需要经常重新分配内部数组的大小,效果可能较差.</li>
<li><code>Vector</code>,<code>Stack</code>均线程安全,但不建议使用.若需要保证线程安全,可考虑使用<code>Collections</code>将集合包装成线程安全的集合.</li>
</ul>

<h1 id="5-map-集合">5.<code>Map</code>集合</h1>

<p><code>Map</code>用于保存具有映射关系的数据,因此<code>Map</code>集合里保存着两组值,一组值用于保存<code>Map</code>里的<code>key</code>,另外一组用于保存<code>Map</code>里的<code>value</code>,<code>key</code>和<code>value</code>都可以是任何引用类型的数据.<code>Map</code>的<code>key</code>不允许重复,即同一个<code>Map</code>对象的任何两个<code>key</code>通过<code>equals()</code>方法比较总是返回<code>false</code>.</p>

<p><code>key</code>和<code>value</code>之间存在单向一对一关系,即通过指定的<code>key</code>,总能找到唯一的,确定的<code>value</code>.从<code>Map</code>中取出数据时,只要给出指定的<code>key</code>,就可以取出对应的<code>value</code>.</p>

<h2 id="5-1-map-中的基本方法">5.1<code>Map</code>中的基本方法</h2>

<p><strong>示例方法:</strong></p>

<pre><code class="language-java">    @Test
    public void test9() {
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;Java&quot;, 1);
        map.put(&quot;Go&quot;, 5);
        map.put(&quot;Python&quot;, 3);
        map.put(&quot;Swift&quot;, 4);
        //put方法,在key不存在时为新增,key存在时为替换
        map.put(&quot;Go&quot;, 2);
        System.out.println(map);
        //仅当key存在时,才会进行value替换
        map.replace(&quot;Php&quot;, 5);
        map.replace(&quot;Java&quot;, 0);
        System.out.println(map);
        //在key存在的情况下,会进行value与参数的计算,将得到的新值替换原value
        map.merge(&quot;Go&quot;, 4, (oldVal, param) -&gt; oldVal + param);
        //在key不存在的情况下,会将新增key-value,key为输入的key,value为输入的参数
        map.merge(&quot;Php&quot;, 7, (oldVal, param) -&gt; oldVal + param);
        System.out.println(map);
        //当key对应的value为null或空时,会新增此key-value
        map.computeIfAbsent(&quot;Java&quot;, (key) -&gt; key.length());
        map.computeIfAbsent(&quot;Java Script&quot;, (key) -&gt; key.length());
        System.out.println(map);
        //当key对应的value存在时(不为空,不为null),会将计算后的值替换value
        map.computeIfPresent(&quot;Java&quot;, (key, value) -&gt; key.length() * (value + 1));
        map.computeIfPresent(&quot;C++&quot;, (key, value) -&gt; Integer.valueOf(key) * value);
        System.out.println(map);
        //获取map中value的集合
        Collection&lt;Integer&gt; values = map.values();
        System.out.println(values);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>{Java=1, Go=2, Swift=4, Python=3}
{Java=0, Go=2, Swift=4, Python=3}
{Java=0, Go=6, Php=7, Swift=4, Python=3}
{Java=0, Java Script=11, Go=6, Php=7, Swift=4, Python=3}
{Java=4, Java Script=11, Go=6, Php=7, Swift=4, Python=3}
[4, 11, 6, 7, 4, 3]
</code></pre>

<h2 id="5-2-hashmap-和-hashtable">5.2<code>HashMap</code>和<code>Hashtable</code></h2>

<p><code>HashMap</code>和<code>Hashtable</code>都是<code>Map</code>接口的典型实现类,它们之间的关系完全类似于<code>ArrayList</code>和<code>Vector</code>的关系.</p>

<p><code>Java8</code>改进了<code>HashMap</code>的实现,使用<code>HashMap</code>存在<code>key</code>冲突时依然具有较好的性能.</p>

<p><code>HashMap</code>和<code>Hashtable</code>存在两点典型区别</p>

<p><code>Hashtable</code>是一个线程安全的<code>Map</code>实现,但<code>HashMap</code>是线程不安全的实现,所以<code>HashMap</code>比<code>Hashtable</code>的性能高一点;但如果有多个线程访问同一个<code>Map</code>对象时,不建议使用<code>Hashtable</code>,可通过<code>Collections</code>工具类把<code>HashMap</code>变成线程安全的.</p>

<p><code>Hashtable</code>不允许使用<code>null</code>作为<code>key</code>和<code>value</code>,如果试图把<code>null</code>值放进<code>Hashtable</code>中,将会引发<code>NullPointerException</code>异常,但<code>HashMap</code>可以使用<code>null</code>作为<code>key</code>或<code>value</code>.</p>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    @Test
    public void test10() {
        //HashMap允许key-value值为null
        HashMap map = new HashMap();
        map.put(null, null);
        map.put(&quot;a&quot;, null);
        map.put(null, null);
        System.out.println(map);
        Hashtable hashtable = new Hashtable();
        //Hashtable不允许key,value为null,否则触发NullPointerException
        //hashtable.put(null, &quot;a&quot;);
        //hashtable.put(&quot;a&quot;, null);
        System.out.println(hashtable);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>{null=null, a=null}
{}
</code></pre>

<p>当使用自定义类作为<code>HashMap</code>,<code>Hashtable</code>的<code>key</code>时,如果重写该类的<code>equals(Object o)</code>和<code>hashCode()</code>方法,则应该保证两个方法的判断标准一致.它们对<code>key</code>的要求与<code>HashSet</code>对集合元素的要求完全相同.</p>

<p>与<code>HashSet</code>类似的是,尽量不要使用可变对象作为<code>HashMap</code>,<code>Hashtable</code>的<code>key</code>,如果确实需要使用可变对象作为<code>HashMap</code>,<code>Hashtable</code>的<code>key</code>,则尽量不要在程序中修改作为<code>key</code>的可变对象.</p>

<h2 id="5-3-linkedhashmap-实现类">5.3<code>LinkedHashMap</code>实现类</h2>

<p><code>HashSet</code>有一个<code>LinkedHashSet</code>子类,<code>HashMap</code>也有一个<code>LinkedHashMap</code>子类.<code>LinkedHashMap</code>也使用双向链表来维护<code>key-value</code>对的次序(其实只需要考虑<code>key</code>的次序),该链表负责维护<code>Map</code>的迭代顺序,所以在迭代访问<code>Map</code>里的全部元素时有更好的性能,迭代顺序与<code>key-value</code>对的插入顺序保持一致.由于需要维护顺序,因此在整体性能上要低于<code>HashMap</code>.</p>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    @Test
    public void test11() {
        //按照元素的插入顺序进行保存
        LinkedHashMap&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();
        linkedHashMap.put(&quot;Java&quot;, &quot;First&quot;);
        linkedHashMap.put(&quot;Python&quot;, &quot;Second&quot;);
        linkedHashMap.put(&quot;Go&quot;, &quot;Third&quot;);
        //使用Java8语法对元素进行遍历
        linkedHashMap.forEach((key, value) -&gt; System.out.println(key + &quot;--&gt;&quot; + value));
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>Java--&gt;First
Python--&gt;Second
Go--&gt;Third
</code></pre>

<h2 id="5-4-sortedmap-接口和-treemap-实现类">5.4<code>SortedMap</code>接口和<code>TreeMap</code>实现类</h2>

<p><code>Set</code>接口派生出<code>Sorted</code>子接口,<code>SortedSet</code>接口有一个<code>TreeSet</code>实现类.<code>Map</code>接口派生出<code>SortedMap</code>子接口,<code>SortedMap</code>接口也有一个<code>TreeMap</code>实现类.</p>

<p><code>TreeMap</code>就是一个红黑树数据结构,每个<code>key-value</code>对即作为红黑树的一个节点.<code>TreeMap</code>存储<code>key-value</code>对(节点)时,需要根据<code>key</code>对节点进行排序.<code>TreeMap</code>可以保证所有的<code>key-value</code>对处于有序状态.</p>

<p><code>TreeMap</code>的<code>key</code>如果是自定义类,那么需要重写<code>hashCode()</code>和<code>equals()</code>方法.如果是自然排序,还需要实现<code>Comparable</code>接口,而且要确保<code>compareTo()</code>和<code>equals()</code>方法相同.</p>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    @Test
    public void test12() {
        //排序Map
        TreeMap&lt;Q, String&gt; treeMap = new TreeMap&lt;&gt;();
        treeMap.put(new Q(5), &quot;Java&quot;);
        treeMap.put(new Q(2), &quot;Go&quot;);
        treeMap.put(new Q(-4), &quot;Python&quot;);
        treeMap.put(new Q(-8), &quot;Java Script&quot;);
        System.out.println(treeMap);
        System.out.println(&quot;最小的key-&gt;&quot; + treeMap.firstKey());
        System.out.println(&quot;最大的key-&gt;&quot; + treeMap.lastKey());
        System.out.println(&quot;比Q(-4)大的最小的key&quot; + treeMap.higherKey(new Q(-4)));
        System.out.println(&quot;比Q(-4)小的最大的key&quot; + treeMap.lowerKey(new Q(-4)));
        System.out.println(&quot;大于等于Q(-4),小于Q(2)&quot;+treeMap.subMap(new Q(-4),new Q(2)));
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>{Q{count=-8}=Java Script, Q{count=-4}=Python, Q{count=2}=Go, Q{count=5}=Java}
最小的key-&gt;Q{count=-8}
最大的key-&gt;Q{count=5}
比Q(-4)大的最小的keyQ{count=2}
比Q(-4)小的最大的keyQ{count=-8}
大于等于Q(-4),小于Q(2){Q{count=-4}=Python}
</code></pre>

<h2 id="5-5-weakhashmap-实现类">5.5<code>WeakHashMap</code>实现类</h2>

<p><code>WeakHashMap</code>与<code>HashMap</code>的用法基本相似.与<code>HashMap</code>的区别在于,<code>HashMap</code>的<code>key</code>保留了对实际对象的强引用,这意味着只要该<code>HashMap</code>对象不被销毁,该<code>HashMap</code>的所有<code>key</code>所引用的对象就不会被垃圾回收,<code>HashMap</code>也不会自动删除这些<code>key</code>所对应的<code>key-value</code>对:但<code>WeakHashMap</code>的<code>key</code>只保留了对实际对象的弱引用,这意味着如果<code>WeakHashMap</code>对象的<code>key</code>所引用的对象没有被其他强引用变量所引用,则这些<code>key</code>所引用的对象可能被垃圾回收,<code>WeakHashMap</code>也可能自动删除这些<code>key</code>所对应的<code>key-value</code>对.</p>

<p><code>WeakedHashMap</code>中的每个<code>key</code>对象只持有对实际对象的弱引用,因此,当垃圾回收了该<code>key</code>所对应的实际对象之后,<code>WeakHashMap</code>会自动删除该<code>key</code>对应的<code>key-value</code>对.
<strong>示例代码:</strong></p>

<pre><code class="language-java">    @Test
    public void test13() {
        WeakHashMap&lt;String, String&gt; weakHashMap = new WeakHashMap&lt;&gt;();
        //new String生成的对象都是匿名字符串对象,没有其它强引用
        weakHashMap.put(new String(&quot;Java&quot;), &quot;1&quot;);
        weakHashMap.put(new String(&quot;Python&quot;), &quot;2&quot;);
        weakHashMap.put(new String(&quot;Go&quot;), &quot;3&quot;);
        //&quot;java script&quot;是一个系统缓存的字符串直接量,系统会直接保留对该字符串对象的强引用,所以垃圾回收时不会回收它
        weakHashMap.put(&quot;java script&quot;, &quot;4&quot;);
        System.out.println(weakHashMap);
        System.gc();
        System.runFinalization();
        System.out.println(&quot;after GC weakHashMap-&gt;&quot; + weakHashMap);
        System.out.println(&quot;==============================&quot;);
        //HashMap保留了对实际对象的强引用,所以只要HashMap对象没有被销毁,该对象的所有key引用的对象就不会被回收.
        HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();
        hashMap.put(new String(&quot;Java&quot;), &quot;1&quot;);
        hashMap.put(new String(&quot;Python&quot;), &quot;2&quot;);
        hashMap.put(new String(&quot;Go&quot;), &quot;3&quot;);
        hashMap.put(&quot;java script&quot;, &quot;4&quot;);
        System.out.println(hashMap);
        System.gc();
        System.runFinalization();
        System.out.println(&quot;after GC hashMap-&gt;&quot; + hashMap);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>{Java=1, Python=2, Go=3, java script=4}
after GC weakHashMap-&gt;{java script=4}
==============================
{Java=1, Go=3, java script=4, Python=2}
after GC hashMap-&gt;{Java=1, Go=3, java script=4, Python=2}
</code></pre>

<p><strong>注意:</strong>如果需要使用<code>WeakHashMap</code>的<code>key</code>来保留对象的弱引用,则不要让该<code>key</code>所引用的对象具有任何强引用,否则将失去使用<code>WeakHashMap</code>的意义.</p>

<h2 id="5-6-identityhashmap-实现类">5.6<code>IdentityHashMap</code>实现类</h2>

<p><code>IdentityHashMap</code>类的实现机制与<code>HashMap</code>基本相似,但它在处理两个<code>key</code>相等时比较独特,当且仅当<code>key1</code>==<code>key2</code>时,<code>IdentityHashMap</code>才认为两个<code>key</code>相等.而<code>HashMap</code>则是根据<code>equals</code>是否返回<code>true</code>,以及它们的<code>hashCode()</code>值相等进行判断根据.</p>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    @Test
    public void test14() {
        //key值根据是否==作为判断依据
        IdentityHashMap&lt;String, String&gt; identityHashMap = new IdentityHashMap&lt;&gt;();
        //new String()生成新的对象,即使放入的字符串相同,但生成的字符串对象地址不同,所以==不同
        identityHashMap.put(new String(&quot;AA&quot;), &quot;11&quot;);
        identityHashMap.put(new String(&quot;AA&quot;), &quot;22&quot;);
        //&quot;BB&quot;为系统字符串常量,指向地址相同
        identityHashMap.put(&quot;BB&quot;, &quot;33&quot;);
        identityHashMap.put(&quot;BB&quot;, &quot;44&quot;);
        System.out.println(&quot;identityHashMap&quot; + identityHashMap);
        //根据equals()和hashCode()进行判断
        HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();
        hashMap.put(new String(&quot;AA&quot;), &quot;11&quot;);
        hashMap.put(new String(&quot;AA&quot;), &quot;22&quot;);
        hashMap.put(&quot;BB&quot;, &quot;33&quot;);
        hashMap.put(&quot;BB&quot;, &quot;44&quot;);
        System.out.println(&quot;hashMap&quot; + hashMap);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>identityHashMap{AA=11, BB=44, AA=22}
hashMap{AA=22, BB=44}
</code></pre>

<h2 id="5-7-enummap-实现类">5.7<code>EnumMap</code>实现类</h2>

<p><code>EnumMap</code>是一个与枚举类一起使用的<code>Map</code>实现,<code>EnumMap</code>中的所有<code>key</code>都必须是单个枚举类的枚举值.创建<code>EnumMap</code>时必须显式或隐式指定它所对应的枚举类.<code>EnumMap</code>具有如下特征:</p>

<ul>
<li><code>EnumMap</code>在内部以数组形式保存,所以这种实现方式非常紧凑,高效.</li>
<li><code>EnumMap</code>根据<code>key</code>的自然顺序(即枚举值在枚举类中的定义顺序)来维护<code>key-value</code>对的顺序.</li>
<li><code>EnumMap</code>不允许使用<code>null</code>作为<code>key</code>,但允许使用<code>null</code>作为<code>value</code>.</li>
</ul>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    enum Time{
        SECOND,MINUTE,HOURS,QUARTER;
    }

    @Test
    public void test15() {
        //初始化enumMap并制定对应的Enum
        EnumMap enumMap = new EnumMap(Time.class);
        enumMap.put(Time.HOURS, &quot;小时&quot;);
        enumMap.put(Time.QUARTER, &quot;刻度&quot;);
        enumMap.put(Time.SECOND, &quot;秒&quot;);
        //按照枚举中定义的顺序排序
        System.out.println(enumMap);
    }
</code></pre>

<p><strong>控制台输出:</strong></p>

<pre><code>{SECOND=秒, HOURS=小时, QUARTER=刻度}
</code></pre>

<h2 id="5-8各-map-实现类的性能分析">5.8各<code>Map</code>实现类的性能分析</h2>

<p><code>HashMap</code>和<code>Hashtable</code>的实现机制几乎一样,但由于<code>Hashtable</code>是一个古老的,线程安全的集合,因此<code>HashMap</code>通常比<code>Hashtable</code>要快.</p>

<p><code>TreeMap</code>中的<code>key-value</code>对总是处于有序状态,无需专门进行排序操作.由于其底层采用红黑树来管理<code>key-value</code>对(红黑树的每个节点就是一个<code>key-value</code>对).因此<code>TreeMap</code>通常比<code>HashMap</code>,<code>Hashtable</code>要慢(尤其是在插入,删除<code>key-value</code>对时更慢)</p>

<p><code>LinkedHashMap</code>比<code>HashMap</code>慢一点,因为它需要维护链表来保持<code>Map</code>中<code>key-value</code>时的添加顺序.</p>

<p><code>IdentityHashMap</code>性能没有特别出色之处,只是判断<code>key</code>的标准是<code>==</code>.</p>

<p><code>EnumMap</code>的性能最好,但它只能使用同一个枚举类的枚举值作为<code>key</code>.</p>

<p><code>HashSet</code>,<code>HashMap</code>和<code>Hashtable</code>默认的负载极限是<code>0.75</code></p>

<h2 id="5-9同步控制">5.9同步控制</h2>

<p><code>Collections</code>类中提供了多个<code>synchronizedXxx()</code>方法,该方法将指定集合包装成线程同步的集合,从而解决多线程并发访问集合时的线程安全问题.</p>

<p><strong>示例代码:</strong></p>

<pre><code class="language-java">    @Test
    public void test16() {
        List&lt;Object&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());
        Set&lt;Object&gt; objects = Collections.synchronizedSet(new HashSet&lt;&gt;());
        Map&lt;Object, Object&gt; hashMap = Collections.synchronizedMap(new HashMap&lt;&gt;());
    }
</code></pre>

                        </div>

                        


                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/14-java%E9%9B%86%E5%90%88/">Java集合</a></li>
        
        <li><a href="/post/13-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">代理模式</a></li>
        
        <li><a href="/post/12-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/">状态模式</a></li>
        
        <li><a href="/post/11-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">组合模式</a></li>
        
        <li><a href="/post/10-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">迭代器模式</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="https://wangjc95.com/tags/%E7%96%AF%E7%8B%82java%E8%AE%B2%E4%B9%89%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0">疯狂Java讲义第三版读书笔记</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "Alex-2017/comment"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://wangjc95.com">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wangjc95.com/post/1-java%E9%9B%86%E5%90%88/" title="Java集合">Java集合</a>
    </li>
    
    <li>
        <a href="https://wangjc95.com/post/14-java%E9%9B%86%E5%90%88/" title="Java集合">Java集合</a>
    </li>
    
    <li>
        <a href="https://wangjc95.com/post/13-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="代理模式">代理模式</a>
    </li>
    
    <li>
        <a href="https://wangjc95.com/post/12-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" title="状态模式">状态模式</a>
    </li>
    
    <li>
        <a href="https://wangjc95.com/post/11-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" title="组合模式">组合模式</a>
    </li>
    
    <li>
        <a href="https://wangjc95.com/post/10-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="迭代器模式">迭代器模式</a>
    </li>
    
    <li>
        <a href="https://wangjc95.com/post/9-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" title="模版方法模式">模版方法模式</a>
    </li>
    
    <li>
        <a href="https://wangjc95.com/post/8-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" title="外观模式">外观模式</a>
    </li>
    
    <li>
        <a href="https://wangjc95.com/post/7-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="适配器模式">适配器模式</a>
    </li>
    
    <li>
        <a href="https://wangjc95.com/post/6-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" title="命令模式">命令模式</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://wangjc95.com/categories/javase/">javase(2)</a>
    </li>
    
    <li>
        <a href="https://wangjc95.com/categories/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">java设计模式(13)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://wangjc95.com/tags/head-first-design-patterns%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">head-first-design-patterns读书笔记</a>
    
    <a href="https://wangjc95.com/tags/%E7%96%AF%E7%8B%82java%E8%AE%B2%E4%B9%89%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">疯狂java讲义第三版读书笔记</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://wangjc95.com/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="https://wangjc95.com">Alex的博客 By Alex</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>



<script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>
</html>
