<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Alex的博客</title>
    <link>https://wangjc95.com/</link>
    <description>Recent content on Alex的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 20 Aug 2017 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://wangjc95.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://wangjc95.com/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://wangjc95.com/about/</guid>
      
        <description>&lt;p&gt;Alex.普普通通的一个码农!&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>https://wangjc95.com/post/3-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 28 Feb 2019 21:00:00 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/3-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>

&lt;p&gt;&lt;strong&gt;介绍:&lt;/strong&gt; 这是阅读&lt;code&gt;head first design patterns&lt;/code&gt;的阅读笔记.&lt;/p&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;1-应用场景&#34;&gt;1.应用场景&lt;/h1&gt;

&lt;p&gt;​   一点点奶茶店如今在一线及二线城市中大受欢迎,并且在以迅速的速度扩张着.与此同时带来了一个问题,由于订单量暴增,他们的订单管理系统支撑不住了.需要设计一个新的系统,并且能够灵活,快速的改动.&lt;/p&gt;

&lt;p&gt;​   下面介绍下一点点,它是一家饮品店.主要卖的饮料分为奶制品,茶,果汁,在饮料的基础上可以根据个人需要添加配料,常见的配料有珍珠,椰果,奶盖等.因此饮品的价钱是由客户选择的饮品类型和配料多少来决定的.&lt;/p&gt;

&lt;h1 id=&#34;2-如何设计&#34;&gt;2.如何设计?&lt;/h1&gt;

&lt;h2 id=&#34;2-1第一种&#34;&gt;2.1第一种&lt;/h2&gt;

&lt;p&gt;创建一个&lt;code&gt;Bverage&lt;/code&gt;抽象类,抽象方法&lt;code&gt;cost()&lt;/code&gt;,每种不同类型的饮品都需要新建一个类并且重写&lt;code&gt;cost()&lt;/code&gt;方法返回对应的价钱.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Alex-2017/image-respository/master/img/20190228204606.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从上面的类图中可以看出,10种饮料就意味着要10个子类.如果遇上了配料价格变动的需求,就需要将所有涉及到该配料的&lt;code&gt;cost&lt;/code&gt;方法重写.维护这种项目光是想想就让人头皮发麻.&lt;/p&gt;

&lt;h2 id=&#34;2-2第二种&#34;&gt;2.2第二种&lt;/h2&gt;

&lt;p&gt;另一种的方式就是将是否添加配料和配料的价钱放在父类&lt;code&gt;Bverage&lt;/code&gt;中,只有每种不同的饮品才会去继承&lt;code&gt;Bverage&lt;/code&gt;类,根据是否添加配料的方法来计算价钱.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Alex-2017/image-respository/master/img/20190228205320.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这种方式比第一种要简洁了很多,但是有如下问题:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;饮品必须强制继承所有的配料方法,这是不实际的.&lt;/li&gt;
&lt;li&gt;无法添加多个相同的配料&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;3-装饰者模式&#34;&gt;3.装饰者模式&lt;/h1&gt;

&lt;p&gt;在这种情况下就可以引入装饰者模式了!&lt;/p&gt;

&lt;h2 id=&#34;3-1定义&#34;&gt;3.1定义&lt;/h2&gt;

&lt;p&gt;通过继承和组合的方式动态地将责任附加到对象上,而不会改动原有的代码.&lt;/p&gt;

&lt;h2 id=&#34;3-2设计原则&#34;&gt;3.2设计原则&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;开放原则:&lt;/strong&gt;类应该对扩展开放,对修改关闭.&lt;/p&gt;

&lt;h2 id=&#34;3-3类图&#34;&gt;3.3类图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Alex-2017/image-respository/master/img/20190228173424.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-4实现代码&#34;&gt;3.4实现代码&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Bverage.java&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package decorator.bverages;

/**
 * @Author WangJiChao
 * @Date 2019/2/26 22:20
 * @Desc 饮料抽象类
 */
public abstract class Bverage {

    public static final int BIG = 1;
    public static final int MEDIUM = 2;
    public static final int SMALL = 3;

    //描述信息
    protected String descrption;

    //容量大小
    private int size;

    //返回描述信息
    public String getDescrption() {
        return descrption;
    }

    //返回价格
    public abstract double cost();

    public int getSize() {
        return size;
    }

    public void setSize(int size) {
        this.size = size;
    }

    protected Bverage() {
    }

    public Bverage(int size) {
        this.size = size;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Bverage&lt;/code&gt;的饮品子类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package decorator.bverages.subClasses;

import decorator.bverages.Bverage;

/**
 * @Author WangJiChao
 * @Date 2019/2/26 22:21
 * @Desc 果汁
 */
public class Juice extends Bverage {

    public Juice() {
        descrption = &amp;quot;Juice&amp;quot;;
    }

    @Override
    public double cost() {
        return 10.5;
    }
}


package decorator.bverages.subClasses;

import decorator.bverages.Bverage;

/**
 * @Author WangJiChao
 * @Date 2019/2/26 22:20
 * @Desc 奶茶
 */
public class MilkTea extends Bverage{

    public MilkTea() {
        descrption = &amp;quot;Milk Tea&amp;quot;;
    }

    @Override
    public double cost() {
        return 9.5;
    }
}


package decorator.bverages.subClasses;

import decorator.bverages.Bverage;

/**
 * @Author WangJiChao
 * @Date 2019/2/26 22:20
 * @Desc 茶
 */
public class Tea extends Bverage {

    public Tea() {
        descrption = &amp;quot;Tea&amp;quot;;
    }

    @Override
    public double cost() {
        return 8.5;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Ingredient.java&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package decorator.ingredients;

import decorator.bverages.Bverage;

/**
 * @Author WangJiChao
 * @Date 2019/2/26 22:21
 * @Desc 配料
 */
public abstract class Ingredient extends Bverage {

    //将getDescrption重写为抽象方法
    @Override
    public abstract String getDescrption();

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Ingredient&lt;/code&gt;的配料子类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package decorator.ingredients.subClasses;

import decorator.bverages.Bverage;
import decorator.ingredients.Ingredient;

/**
 * @Author WangJiChao
 * @Date 2019/2/26 22:21
 * @Desc 椰果
 */
public class Cocount extends Ingredient {

    private Bverage bverage;

    public Cocount(Bverage bverage) {
        this.bverage = bverage;
    }

    @Override
    public String getDescrption() {
        return bverage.getDescrption() + &amp;quot;,Cocount&amp;quot;;
    }

    @Override
    public int getSize() {
        return bverage.getSize();
    }

    //根据饮料容量大小设置配料价格
    @Override
    public double cost() {
        double cost = bverage.cost();
        if (bverage.getSize() == Bverage.BIG) {
            cost += 3;
        } else if (bverage.getSize() == Bverage.MEDIUM) {
            cost += 2.5;
        } else if (bverage.getSize() == Bverage.SMALL) {
            cost += 2;
        }
        return cost;
    }
}


package decorator.ingredients.subClasses;

import decorator.bverages.Bverage;
import decorator.ingredients.Ingredient;

/**
 * @Author WangJiChao
 * @Date 2019/2/26 22:22
 * @Desc 奶盖
 */
public class MilkCap extends Ingredient {
    private Bverage bverage;

    public MilkCap(Bverage bverage) {
        this.bverage = bverage;
    }

    @Override
    public String getDescrption() {
        return bverage.getDescrption() + &amp;quot;,MilkCap&amp;quot;;
    }

    @Override
    public int getSize() {
        return bverage.getSize();
    }

    //根据饮料容量大小设置配料价格
    @Override
    public double cost() {
        double cost = bverage.cost();
        if (bverage.getSize() == Bverage.BIG) {
            cost += 4;
        } else if (bverage.getSize() == Bverage.MEDIUM) {
            cost += 3.5;
        } else if (bverage.getSize() == Bverage.SMALL) {
            cost += 3;
        }
        return cost;
    }

}


package decorator.ingredients.subClasses;

import decorator.bverages.Bverage;
import decorator.ingredients.Ingredient;

/**
 * @Author WangJiChao
 * @Date 2019/2/26 22:21
 * @Desc 珍珠
 */
public class Pearl extends Ingredient {

    private Bverage bverage;

    public Pearl(Bverage bverage) {
        this.bverage = bverage;
    }

    @Override
    public String getDescrption() {
        return bverage.getDescrption() + &amp;quot;,Pearl&amp;quot;;
    }

    @Override
    public int getSize() {
        return bverage.getSize();
    }

    //根据饮料容量大小设置配料价格
    @Override
    public double cost() {
        double cost = bverage.cost();
        if (bverage.getSize() == Bverage.BIG) {
            cost += 5;
        } else if (bverage.getSize() == Bverage.MEDIUM) {
            cost += 4.5;
        } else if (bverage.getSize() == Bverage.SMALL) {
            cost += 4;
        }
        return cost;
    }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;测试代码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
    public void test1() {
        //纯奶茶
        Bverage milkTea = new MilkTea();
        System.out.println(milkTea.getDescrption() + &amp;quot; costs $&amp;quot; + milkTea.cost());

        //茶+奶盖+珍珠+椰果
        Bverage tea = new Tea();
        //设置饮品容量为大
        tea.setSize(Bverage.BIG);
        tea = new MilkCap(tea);
        tea = new Pearl(tea);
        tea = new Cocount(tea);
        System.out.println(tea.getDescrption() + &amp;quot; costs $&amp;quot; + tea.cost());

        //果汁+珍珠+双奶盖
        Bverage juice = new Juice();
        //设置饮品容量为中
        juice.setSize(Bverage.MEDIUM);
        juice = new Pearl(juice);
        juice = new MilkCap(juice);
        juice = new MilkCap(juice);
        System.out.println(juice.getDescrption() + &amp;quot; costs $&amp;quot; + juice.cost());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-5总结&#34;&gt;3.5总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;装饰者模式可以在不改变原有代码的情况下,给对象赋予新功能.既对扩展开发,对修改关闭&lt;/li&gt;
&lt;li&gt;装饰者模式会导致有过多的子类,如果使用者在不了解该模式的情况下,会觉得此设计晦涩难懂.&lt;/li&gt;
&lt;li&gt;使用装饰者模式会可能会有大量的实例化代码,可搭配工厂模式或者建造者模式.&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://wangjc95.com/post/2-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 17 Feb 2019 17:34:00 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/2-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>

&lt;p&gt;&lt;strong&gt;介绍:&lt;/strong&gt; 这是阅读&lt;code&gt;head first design patterns&lt;/code&gt;的阅读笔记.&lt;/p&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;1-观察者模式&#34;&gt;1.观察者模式&lt;/h1&gt;

&lt;h2 id=&#34;1-1定义&#34;&gt;1.1定义&lt;/h2&gt;

&lt;p&gt;观察者模式定义了对象之间的一对多依赖,这样一来,当一个对象改变状态时,它的所有依赖者都会收到通知并自动更新.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Alex-2017/image-respository/master/img/20190217170741.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-2设计原则&#34;&gt;1.2设计原则&lt;/h2&gt;

&lt;p&gt;为了交互对象之间的松耦合设计而努力.&lt;/p&gt;

&lt;h1 id=&#34;2-情景模拟&#34;&gt;2.情景模拟&lt;/h1&gt;

&lt;h2 id=&#34;2-1情景介绍&#34;&gt;2.1情景介绍&lt;/h2&gt;

&lt;p&gt;建立一个天气推送应用,拉取气象站的最新数据(比如湿度,温度,气压等数据).并在显示装置中进行显示.&lt;strong&gt;显示装置会有多个.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-2结构图&#34;&gt;2.2结构图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Alex-2017/image-respository/master/img/20190217170639.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;3-代码实现&#34;&gt;3.代码实现&lt;/h1&gt;

&lt;h2 id=&#34;2-1代码类图&#34;&gt;2.1代码类图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Alex-2017/image-respository/master/img/20190217170835.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-2自定义搭建&#34;&gt;2.2自定义搭建&lt;/h2&gt;

&lt;h3 id=&#34;2-2-1接口&#34;&gt;2.2.1接口&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Interface.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package observer.interfaces;
/**
 * @Author WangJiChao
 * @Date 2019/2/17 17:11
 * @Desc 存储所需接口类
 */
public class Interface {

    //主题接口,用于注册,添加和通知观察者
    public interface Subject {
        void registerObserver(Observer observer);
        void removeObserver(Observer observer);
        void notifyObserver();
    }

    //观察者接口,更新观察者中的数据
    public interface Observer{
        void update(float temp, float humidity, float pressure);
    }

    //公告板接口,展示观察者中的数据
    public interface DisplayElement{
        void display();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-2主题对象&#34;&gt;2.2.2主题对象&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;WeatherData.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package observer.subjects;

import observer.interfaces.Interface;
import java.util.ArrayList;

/**
 * @Author WangJiChao
 * @Date 2019/2/17 13:02
 * @Desc 实现Subject接口,存储实时的空气数据并告知给观察者.
 */
public class WeatherData implements Interface.Subject {
    //观察者列表
    private ArrayList&amp;lt;Interface.Observer&amp;gt; observers;
    private float temperature;
    private float humidity;
    private float pressure;

    public WeatherData() {
        observers = new ArrayList&amp;lt;&amp;gt;();
    }

    @Override
    public void registerObserver(Interface.Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Interface.Observer observer) {
        int i = observers.indexOf(observer);
        if (i &amp;gt;= 0) {
            observers.remove(i);
        }
    }

    @Override
    public void notifyObserver() {
        for (Interface.Observer observer : observers) {
            observer.update(temperature,humidity,pressure);
        }
    }

    public void measureChanged() {
        notifyObserver();
    }

    public void setMeasurements(float temperature,float humidity,float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        measureChanged();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-3观察者&#34;&gt;2.2.3观察者&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;CurrentConditionDisplay.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package observer.subscribes;

import observer.interfaces.Interface;
/**
 * @Author WangJiChao
 * @Date 2019/2/17 13:04
 * @Desc 展示当前天气的观察者
 */
public class CurrentConditionDisplay implements Interface.Observer,Interface.DisplayElement {

    private Interface.Subject weatherData;
    private float temperature;
    private float humidity;

    public CurrentConditionDisplay(Interface.Subject weatherData) {
        //保存主题接口的引用
        this.weatherData = weatherData;
        //将其注册到主题借口中去
        weatherData.registerObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        this.temperature = temp;
        this.humidity = humidity;
        display();
    }

    @Override
    public void display() {
        System.out.println(String.format(&amp;quot;CurrentCondition is %f temperatrue and %f humidity&amp;quot;,temperature,humidity));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ForecastDisplay.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package observer.subscribes;

import observer.interfaces.Interface;
import observer.subjects.WeatherData;
/**
 * @Author WangJiChao
 * @Date 2019/2/17 16:13
 * @Desc 天气预测的观察者
 */
public class ForecastDisplay implements Interface.Observer,Interface.DisplayElement {
    private float currentPressure = 29.92f;
    private float lastPressure;
    private WeatherData weatherData;

    public ForecastDisplay(WeatherData weatherData) {
        this.weatherData = weatherData;
        weatherData.registerObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        lastPressure = currentPressure;
        currentPressure = pressure;
        display();
    }

    @Override
    public void display() {
        System.out.print(&amp;quot;Forecast: &amp;quot;);
        if (currentPressure &amp;gt; lastPressure) {
            System.out.println(&amp;quot;Improving weather on the way!&amp;quot;);
        } else if (currentPressure == lastPressure) {
            System.out.println(&amp;quot;More of the same&amp;quot;);
        } else if (currentPressure &amp;lt; lastPressure) {
            System.out.println(&amp;quot;Watch out for cooler, rainy weather&amp;quot;);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-4测试代码&#34;&gt;2.2.4测试代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; //不使用Java自带的observer类模拟实现天气站数据的输送.
    @Test
    public void test1() {
        WeatherData weatherData = new WeatherData();
        CurrentConditionDisplay currentConditionDisplay = new CurrentConditionDisplay(weatherData);
        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);
        weatherData.setMeasurements(1.1f,2.2f,3.3f);
        weatherData.setMeasurements(2,3,4.01f);
        weatherData.setMeasurements(12.12f,13,22.01f);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结果输出:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CurrentCondition is 1.100000 temperatrue and 2.200000 humidity
Forecast: Watch out for cooler, rainy weather
CurrentCondition is 2.000000 temperatrue and 3.000000 humidity
Forecast: Improving weather on the way!
CurrentCondition is 12.120000 temperatrue and 13.000000 humidity
Forecast: Improving weather on the way!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-3使用-java-内置类搭建&#34;&gt;2.3使用&lt;code&gt;Java&lt;/code&gt;内置类搭建&lt;/h2&gt;

&lt;h3 id=&#34;2-3-1主题对象&#34;&gt;2.3.1主题对象&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;WeatherData.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package observer.observable;

import java.util.Observable;

//继承java内置的Observable类,不必再实现添加,删除,通知观察者等方法
public class WeatherData extends Observable {

    private float temperature;
    private float humidity;
    private float pressure;
    
    public WeatherData() {
    }

    public void measureChanged() {
        //设置父类Observable中的change为true,当change为true时才会通知观察者.
        setChanged();
        //通知观察者
        notifyObservers();
    }

    //获取最新数据并调用measureChanged方法
    public void setMeasurements(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        measureChanged();
    }

    public float getTemperature() {
        return temperature;
    }

    public float getHumidity() {
        return humidity;
    }

    public float getPressure() {
        return pressure;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-2观察者&#34;&gt;2.3.2观察者&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;CurrentConditionDisplay.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package observer.observable;

import observer.interfaces.Interface;

import java.util.Observable;
import java.util.Observer;

/**
 * @Author WangJiChao
 * @Date 2019/2/17 16:15
 * @Desc 实现java内置接口自定义当前天气观察者
 */
public class CurrentConditionDisplay implements Observer, Interface.DisplayElement {
    
    private float temperature;
    private float humidity;
    private float pressure;

    private Observable observable;

    //将Observable保存并将自身注册到Observable
    public CurrentConditionDisplay(Observable observable) {
        this.observable = observable;
        observable.addObserver(this);
    }

    //拉取所需数据并调用display方法
    @Override
    public void update(java.util.Observable o, Object arg) {
        if (o instanceof WeatherData) {
            WeatherData weatherData = (WeatherData) o;
            this.temperature = weatherData.getTemperature();
            this.humidity = weatherData.getHumidity();
            this.pressure = weatherData.getPressure();
            display();
        }
    }

    @Override
    public void display() {
        System.out.println(String.format(&amp;quot;CurrentCondition is %f temperatrue and %f humidity&amp;quot;, temperature, humidity));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ForecastDisplay.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package observer.observable;

import observer.interfaces.Interface;
import java.util.Observable;
import java.util.Observer;

/**
 * @Author WangJiChao
 * @Date 2019/2/17 16:15
 * @Desc 实现java内置接口自定义天气预测观察者
 */
public class ForecastDisplay implements Observer,Interface.DisplayElement{
    private float currentPressure = 29.92f;
    private float lastPressure;
    private WeatherData weatherData;

    public ForecastDisplay(WeatherData weatherData) {
        this.weatherData = weatherData;
        weatherData.addObserver(this);
    }

    @Override
    public void update(Observable o, Object arg) {
        if (o instanceof WeatherData) {
            WeatherData weatherData = (WeatherData) o;
            this.lastPressure = this.currentPressure;
            this.currentPressure = weatherData.getPressure();
            display();
        }
    }

    @Override
    public void display() {
        System.out.print(&amp;quot;Forecast: &amp;quot;);
        if (currentPressure &amp;gt; lastPressure) {
            System.out.println(&amp;quot;Improving weather on the way!&amp;quot;);
        } else if (currentPressure == lastPressure) {
            System.out.println(&amp;quot;More of the same&amp;quot;);
        } else if (currentPressure &amp;lt; lastPressure) {
            System.out.println(&amp;quot;Watch out for cooler, rainy weather&amp;quot;);
        }
    }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-3测试代码&#34;&gt;2.3.3测试代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
    public void test2() {
        observer.observable.WeatherData weatherData = new observer.observable.WeatherData();
        observer.observable.CurrentConditionDisplay currentConditionDisplay = new observer.observable.CurrentConditionDisplay(weatherData);
        observer.observable.ForecastDisplay forecastDisplay = new observer.observable.ForecastDisplay(weatherData);
        weatherData.setMeasurements(1.1f,2.2f,3.3f);
        weatherData.setMeasurements(2,3,4.01f);
        weatherData.setMeasurements(12.12f,13,22.01f);
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结果输出:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Forecast: Watch out for cooler, rainy weather
CurrentCondition is 1.100000 temperatrue and 2.200000 humidity
Forecast: Improving weather on the way!
CurrentCondition is 2.000000 temperatrue and 3.000000 humidity
Forecast: Improving weather on the way!
CurrentCondition is 12.120000 temperatrue and 13.000000 humidity

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-4-java-util-observable-的黑暗面&#34;&gt;2.3.4&lt;code&gt;java.util.Observable&lt;/code&gt;的黑暗面&lt;/h3&gt;

&lt;p&gt;它是一个&lt;strong&gt;类&lt;/strong&gt;而不是一个&lt;strong&gt;接口&lt;/strong&gt;,导致了它的局限性.它不能被已经有父类的类继承.因为&lt;code&gt;java&lt;/code&gt;不能多继承.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://wangjc95.com/post/1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 13 Feb 2019 21:30:48 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>

&lt;p&gt;&lt;strong&gt;介绍:&lt;/strong&gt; 这是阅读&lt;code&gt;head first design patterns&lt;/code&gt;的阅读笔记.&lt;/p&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;1-应用场景&#34;&gt;1.应用场景&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Alex-2017/image-respository/master/img/20190213161054.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们有一个鸭子模拟器,通过&lt;code&gt;Duck&lt;/code&gt;父类表示鸭子的行为,子类通过重写&lt;code&gt;display&lt;/code&gt;方法来表示鸭子的特征行为.现在有一个新需求,需要添加一个&lt;code&gt;fly&lt;/code&gt;方法,让鸭子飞起来.&lt;/p&gt;

&lt;h1 id=&#34;2-解决思路&#34;&gt;2.解决思路&lt;/h1&gt;

&lt;h2 id=&#34;2-1在父类中添加-fly-方法&#34;&gt;2.1在父类中添加&lt;code&gt;fly&lt;/code&gt;方法&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Alex-2017/image-respository/master/img/20190213163020.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RubberDuck&lt;/code&gt;无法飞行,所以需要重写&lt;code&gt;fly&lt;/code&gt;方法.&lt;code&gt;WoodenDuck&lt;/code&gt;不能飞行不能叫,需要重写&lt;code&gt;fly&lt;/code&gt;,&lt;code&gt;quack&lt;/code&gt;方法.假设以后还会有新的鸭子被添加而且频率很多!那么维护该项目将会成为一个噩梦.&lt;strong&gt;这是典型的过度使用继承,导致项目维护起来很繁琐!&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-2使用-flyable-quackable-接口&#34;&gt;2.2使用&lt;code&gt;Flyable&lt;/code&gt;,&lt;code&gt;Quackable&lt;/code&gt;接口&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Alex-2017/image-respository/master/img/20190228201407.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;对需要重写方法的子类,让它们去实现对应的接口.这样做的坏处很明显,若新增了需要重写的方法,就要添加对应的接口.另外用接口实现的方法无法达到代码复用的目的!&lt;/p&gt;

&lt;p&gt;以上两种方式都无法优雅的解决添加&lt;code&gt;fly&lt;/code&gt;方法的问题,下面我们来看几个设计原则.&lt;/p&gt;

&lt;h2 id=&#34;2-3设计原则&#34;&gt;2.3设计原则&lt;/h2&gt;

&lt;h3 id=&#34;2-3-1封装变化&#34;&gt;2.3.1封装变化&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Identity the aspects of your application that vary and separate them from what stays the same.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-3-2面向接口编程&#34;&gt;2.3.2面向接口编程&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Program to an interface,not an implementation.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-3-3多用组合-少用继承&#34;&gt;2.3.3多用组合,少用继承&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Favor composition over inheritance&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-4封装行为&#34;&gt;2.4封装行为&lt;/h2&gt;

&lt;p&gt;以设计原则为基础,对变化的部分进行封装.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Alex-2017/image-respository/master/img/20190213204139.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;将飞行行为和呱呱叫行为封装为接口并根据不同类型生成对应的实现类.然后将&lt;code&gt;FlyBeahvior&lt;/code&gt;和&lt;code&gt;QuackBehavior&lt;/code&gt;放置在&lt;code&gt;Duck&lt;/code&gt;类中.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Duck.java&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class Duck {

    public Duck(){

    }

    /**
     * 将会变化的飞行,呱呱叫行为从不会变化的代码中分离出来,通过用接口来替代.在Duck的子类中给Behavior设定对应的实现对象.
     */
    protected FlyBehavior flyBehavior;
    protected QuackBehavior quackBehavior;
    
    public abstract void display();

    public void swim() {
        System.out.println(&amp;quot;we all can swim!&amp;quot;);
    }

    public void performFly() {
        flyBehavior.fly();
    }

    public void performQuack() {
        quackBehavior.quack();
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-代码展示&#34;&gt;3.代码展示&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Alex-2017/image-respository/master/img/20190228203725.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-1行为接口&#34;&gt;3.1行为接口&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;FlyBehavior.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @Author Alex
 * @Date 2019/1/30 17:41
 * @Desc 代表飞行行为,通过不同的接口来实现不同的飞行行为.
 */
public interface FlyBehavior {
    void fly();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;QuackBehavior.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @Author Alex
 * @Date 2019/1/30 17:42
 * @Desc 代表呱呱叫行为
 */
public interface QuackBehavior {
    void quack();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-2行为接口实现类&#34;&gt;3.2行为接口实现类&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;FlyByRocket.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FlyByRocket implements FlyBehavior {
    @Override
    public void fly() {
        System.out.println(&amp;quot;fly by rocket&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;FlyNoWay.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FlyNoWay implements FlyBehavior {
    //无法飞行
    @Override
    public void fly() {
        System.out.println(&amp;quot;can not fly!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;FlyWithWings.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FlyWithWings implements FlyBehavior {
    //用翅膀飞行
    @Override
    public void fly() {
        System.out.println(&amp;quot;fly with wings in the sky!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;MuteQuack.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MuteQuack implements QuackBehavior {
    //变异鸭子 无法叫出声.
    @Override
    public void quack() {
        System.out.println(&amp;quot;I&#39;m mute duck,can not quack!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Quack.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Quack implements QuackBehavior {
    //表示正常鸭子的呱呱叫
    @Override
    public void quack() {
        System.out.println(&amp;quot;quack quack quack&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-3鸭子父类&#34;&gt;3.3鸭子父类&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Duck.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class Duck {

    public Duck(){

    }

    /**
     * 将会变化的飞行,呱呱叫行为从不会变化的代码中分离出来,通过用接口来替代.在Duck的子类中给Behavior设定对应的实现对象.
     */
    protected FlyBehavior flyBehavior;
    protected QuackBehavior quackBehavior;

    /**
     * 动态设置FlyBehavior实现类
     */
    public void setFlyBehavior(FlyBehavior f) {
        flyBehavior = f;
    }

    public abstract void display();

    public void swim() {
        System.out.println(&amp;quot;we all can swim!&amp;quot;);
    }

    public void performFly() {
        flyBehavior.fly();
    }

    public void performQuack() {
        quackBehavior.quack();
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-4鸭子子类&#34;&gt;3.4鸭子子类&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;MallardDuck.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MallardDuck extends Duck {


    public MallardDuck() {
        //在构造器中指定对应的行为实现类
        flyBehavior = new FlyWithWings();
        quackBehavior = new Quack();
    }

    @Override
    public void display() {
        System.out.println(&amp;quot;I&#39;m MallardDuck&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-5测试类&#34;&gt;3.5测试类&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;StrategyTest.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class StrategyTest {
    @Test
    public void test1() {
        Duck mallardDuck = new MallardDuck();
        mallardDuck.display();
        mallardDuck.performFly();
        mallardDuck.performQuack();
    }

    @Test
    public void test2() {
        Duck duck = new MallardDuck();
        duck.performFly();
        //动态设置 Behavior
        duck.setFlyBehavior(new FlyByRocket());
        duck.performFly();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;4-策略模式&#34;&gt;4.策略模式&lt;/h1&gt;

&lt;h2 id=&#34;4-1定义&#34;&gt;4.1定义&lt;/h2&gt;

&lt;p&gt;定义这样的解决方法就叫做策略模式,策略模式就是&lt;strong&gt;定义并进行封装一组算法,它们之间可自由交互,独立于客户端.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-2类型&#34;&gt;4.2类型&lt;/h2&gt;

&lt;p&gt;行为类模式&lt;/p&gt;

&lt;h2 id=&#34;4-3优缺点&#34;&gt;4.3优缺点&lt;/h2&gt;

&lt;h3 id=&#34;4-3-1优点&#34;&gt;4.3.1优点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;策略类之间可以自由切换,由于策略类实现自同一个抽象,所以他们之间可以自由切换.&lt;/li&gt;
&lt;li&gt;易于扩展,增加一个新的策略对策略模式来说非常容易,基本上可以在不改变原有代码的基础上进行扩展.&lt;/li&gt;
&lt;li&gt;避免使用多重条件,如果不使用策略模式,对于所有的算法,必须使用条件语句进行连接,通过条件判断来决定使用哪一种算法,在上一篇文章中我们已经提到,使用多重条件判断是非常不容易维护的.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-3-2缺点&#34;&gt;4.3.2缺点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;维护各个策略类会给开发带来额外开销,可能大家在这方面都有经验:一般来说,策略类的数量超过5个,就比较令人头疼了.&lt;/li&gt;
&lt;li&gt;必须对客户端（调用者）暴露所有的策略类，因为使用哪种策略是由客户端来决定的，因此，客户端应该知道有什么策略，并且了解各种策略之间的区别，否则，后果很严重。例如，有一个排序算法的策略模式，提供了快速排序、冒泡排序、选择排序这三种算法，客户端在使用这些算法之前，是不是先要明白这三种算法的适用情况？再比如，客户端要使用一个容器，有链表实现的，也有数组实现的，客户端是不是也要明白链表和数组有什么区别？就这一点来说是有悖于迪米特法则的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-4使用场景&#34;&gt;4.4使用场景&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;几个类的主要逻辑相同,只在部分逻辑的算法和行为上稍有区别的情况.&lt;/li&gt;
&lt;li&gt;有几种相似的行为,或者说算法,客户端需要动态地决定使用哪一种,那么可以使用策略模式,将这些算法封装起来供客户端调用.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前的解决办法并不是最佳的解决办法!因为在子类的构造器中手动构造了所需的行为实现类.&lt;/p&gt;

&lt;p&gt;策略模式是一种简单常用的模式，我们在进行开发的时候，会经常有意无意地使用它，一般来说，策略模式不会单独使用，跟模版方法模式、工厂模式等混合使用的情况比较多。&lt;/p&gt;

&lt;h2 id=&#34;4-5参考文章链接&#34;&gt;4.5参考文章链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/zhengzhb/article/details/7609670&#34;&gt;23种设计模式（12）：策略模式&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>